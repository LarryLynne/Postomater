<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–õ–æ–≥–∏—Å—Ç–∏–∫–∞: –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏ –°–ª–∏—è–Ω–∏–µ</title>
    
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <style>
        body { margin: 0; padding: 0; font-family: sans-serif; display: flex; height: 100vh; }
        
        #sidebar {
            width: 320px;
            background: #f8f9fa;
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto;
            z-index: 1000;
            display: flex; flex-direction: column; gap: 15px;
        }
        
        #map { flex-grow: 1; height: 100%; }

        h2 { font-size: 1.2rem; margin-top: 0; color: #333; }
        .control-group { border-bottom: 1px solid #ddd; padding-bottom: 15px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 0.9rem; }
        input[type="file"], input[type="number"] { width: 100%; box-sizing: border-box; padding: 5px; }
        
        button {
            width: 100%; padding: 10px; background: #007bff; color: white; 
            border: none; cursor: pointer; border-radius: 4px; font-size: 0.9rem; margin-top: 5px;
        }
        button:hover { background: #0056b3; }
        button.calc-btn { background: #6f42c1; font-weight: bold; }
        button.download-btn { background: #28a745; margin-top: auto; }
        
        /* –ö–Ω–æ–ø–∫–∞ —Å–ª–∏—è–Ω–∏—è (–æ—Ä–∞–Ω–∂–µ–≤–∞—è) */
        button.merge-btn { background: #fd7e14; margin-top: 5px; }
        button.merge-btn:hover { background: #e36209; }

        .stats { font-size: 0.85rem; color: #666; margin-top: 10px; white-space: pre-line; }
        
        /* –ú–∞—Ä–∫–µ—Ä –Ω–æ–º–µ—Ä–∞ –≥—Ä—É–ø–ø—ã */
        .group-label {
            background: white;
            border: 2px solid #333;
            border-radius: 50%;
            text-align: center;
            font-weight: bold;
            font-size: 12px;
            line-height: 20px;
            box-shadow: 0 0 4px rgba(0,0,0,0.4);
            color: #333;
        }
        
        .popup-content { font-size: 14px; }
        .popup-section { margin-top: 10px; border-top: 1px solid #eee; padding-top: 8px; }
        .popup-row { display: flex; gap: 5px; align-items: center; margin-bottom: 5px; }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>üöö –õ–æ–≥–∏—Å—Ç–∏–∫–∞ v2.1</h2>
    
    <div class="control-group">
        <label>1. –î–∞–Ω–Ω—ã–µ (Excel)</label>
        <div style="font-size: 0.8rem; color: #666; margin-bottom: 5px;">
            –õ–∏—Å—Ç—ã: "—Å–ª—É–∂–±..." –∏ "–ø–æ—á—Ç..."
        </div>
        <input type="file" id="fileInput" accept=".xlsx, .xls">
        <div id="fileStatus" class="stats">–û–∂–∏–¥–∞–Ω–∏–µ —Ñ–∞–π–ª–∞...</div>
    </div>

    <div class="control-group">
        <label>2. –ù–∞—Å—Ç—Ä–æ–π–∫–∏</label>
        <label style="font-weight: normal; font-size: 0.8rem;">–ú–∞–∫—Å. —Ç–æ—á–µ–∫ –Ω–∞ –≥—Ä—É–ø–ø—É:</label>
        <input type="number" id="maxCapacity" value="50" min="1">
        
        <button class="calc-btn" onclick="calculateDistribution()">‚ö° –†–∞—Å—Å—á–∏—Ç–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
    </div>

    <div class="control-group">
        <label>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</label>
        <p style="font-size: 0.8rem; color:#666;">
            - –ö–ª–∏–∫ –ø–æ —Ç–æ—á–∫–µ: –ø–µ—Ä–µ–Ω–æ—Å/—Å–ª–∏—è–Ω–∏–µ.<br>
            - Drag –∫–∞—Ä—Ç—ã: –ø—Ä–æ—Å–º–æ—Ç—Ä.
        </p>
        <button onclick="redrawMap()">üîÑ –û–±–Ω–æ–≤–∏—Ç—å –∫–∞—Ä—Ç—É</button>
    </div>

    <button class="download-btn" onclick="exportToExcel()">üì• –°–∫–∞—á–∞—Ç—å Excel</button>
</div>

<div id="map"></div>

<script>
    // --- –î–∞–Ω–Ω—ã–µ –∏ –°–ª–æ–∏ ---
    let map;
    let hubsData = [];
    let pointsData = [];
    let layers = {
        hubs: L.layerGroup(),
        points: L.layerGroup(),
        polygons: L.layerGroup(),
        labels: L.layerGroup()
    };

    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
    function initMap() {
        map = L.map('map').setView([50.4501, 30.5234], 11);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap'
        }).addTo(map);

        layers.polygons.addTo(map);
        layers.hubs.addTo(map);
        layers.points.addTo(map);
        layers.labels.addTo(map);
    }
    initMap();

    // --- –ó–∞–≥—Ä—É–∑–∫–∞ Excel ---
    document.getElementById('fileInput').addEventListener('change', handleFile);

    function handleFile(e) {
        const file = e.target.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function(e) {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, {type: 'array'});
            
            const sheetNames = workbook.SheetNames;
            let hubsSheetName = null, pointsSheetName = null;

            sheetNames.forEach(name => {
                const lower = name.toLowerCase();
                if (lower.includes('—Å–ª—É–∂–±')) hubsSheetName = name;
                if (lower.includes('–ø–æ—à—Ç') || lower.includes('–ø–æ—á—Ç')) pointsSheetName = name;
            });

            if (!hubsSheetName) hubsSheetName = sheetNames[0];
            if (!pointsSheetName) pointsSheetName = sheetNames[1] || sheetNames[0];

            const hubsRaw = XLSX.utils.sheet_to_json(workbook.Sheets[hubsSheetName]);
            const pointsRaw = XLSX.utils.sheet_to_json(workbook.Sheets[pointsSheetName]);

            processData(hubsRaw, pointsRaw);
        };
        reader.readAsArrayBuffer(file);
    }

    function processData(hubsRaw, pointsRaw) {
        hubsData = hubsRaw
            .filter(r => r['–®–∏—Ä–æ—Ç–∞'] && r['–î–æ–≤–≥–æ—Ç–∞'])
            .map(h => ({
                id: h['–°–∫–ª–∞–¥'] || h['–ù–∞–∑–≤–∞–Ω–∏–µ'] || 'Unknown',
                lat: parseFloat(h['–®–∏—Ä–æ—Ç–∞']),
                lng: parseFloat(h['–î–æ–≤–≥–æ—Ç–∞'])
            }));

        pointsData = pointsRaw
            .filter(r => r['–®–∏—Ä–æ—Ç–∞'] && r['–î–æ–≤–≥–æ—Ç–∞'])
            .map(p => ({
                id: p['–°–∫–ª–∞–¥'] || p['ID'] || 'Unknown',
                lat: parseFloat(p['–®–∏—Ä–æ—Ç–∞']),
                lng: parseFloat(p['–î–æ–≤–≥–æ—Ç–∞']),
                assignedHub: null,
                groupIndex: 0,
                color: '#cccccc'
            }));

        document.getElementById('fileStatus').innerHTML = `–•–∞–±—ã: ${hubsData.length}\n–¢–æ—á–∫–∏: ${pointsData.length}`;
        drawHubs();
        drawPoints();
    }

    // --- –õ–æ–≥–∏–∫–∞ –†–∞—Å—á–µ—Ç–∞ ---
    function calculateDistribution() {
        if (!hubsData.length) return alert("–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö");
        const maxPerGroup = parseInt(document.getElementById('maxCapacity').value) || 50;
        let colorCounter = 0;

        // 1. –ë–ª–∏–∂–∞–π—à–∏–π –•–∞–±
        pointsData.forEach(p => {
            let nearest = null, min = Infinity;
            const pt = turf.point([p.lng, p.lat]);
            hubsData.forEach(h => {
                const dist = turf.distance(pt, turf.point([h.lng, h.lat]));
                if (dist < min) { min = dist; nearest = h.id; }
            });
            p.assignedHub = nearest;
        });

        // 2. K-Means
        hubsData.forEach(hub => {
            const groupPoints = pointsData.filter(p => p.assignedHub === hub.id);
            if (!groupPoints.length) return;

            const k = Math.ceil(groupPoints.length / maxPerGroup);
            
            if (k <= 1) {
                colorCounter++;
                const col = getDistinctColor(colorCounter);
                groupPoints.forEach(p => { p.groupIndex = 1; p.color = col; });
            } else {
                const tPoints = turf.featureCollection(groupPoints.map(p => turf.point([p.lng, p.lat], {origId: p.id})));
                const clustered = turf.clustersKmeans(tPoints, {numberOfClusters: k});
                
                // –ú–∞–ø–ø–∏–Ω–≥ –∫–ª–∞—Å—Ç–µ—Ä–æ–≤ –Ω–∞ —Ü–≤–µ—Ç–∞
                const clusterMap = {};
                clustered.features.forEach(f => {
                    const cId = f.properties.cluster;
                    if (clusterMap[cId] === undefined) {
                        colorCounter++;
                        clusterMap[cId] = getDistinctColor(colorCounter);
                    }
                    const p = groupPoints.find(gp => gp.id === f.properties.origId);
                    if (p) {
                        p.groupIndex = cId + 1;
                        p.color = clusterMap[cId];
                    }
                });
            }
        });
        redrawMap();
    }

    // --- –û—Ç—Ä–∏—Å–æ–≤–∫–∞ ---
    function drawHubs() {
        layers.hubs.clearLayers();
        const icon = L.divIcon({
            className: 'hub-icon',
            html: "<div style='background:black; color:white; width:24px; height:24px; border-radius:50%; display:flex; align-items:center; justify-content:center; border:2px solid white; box-shadow:0 0 5px black;'>H</div>",
            iconSize: [28, 28]
        });
        hubsData.forEach(h => {
            L.marker([h.lat, h.lng], {icon: icon}).addTo(layers.hubs).bindPopup(`<b>–•–∞–±: ${h.id}</b>`);
        });
    }

    function drawPoints() {
        layers.points.clearLayers();
        pointsData.forEach(p => {
            const icon = L.divIcon({
                className: 'point-icon',
                html: `<div style='background-color:${p.color}; width:10px; height:10px; border-radius:50%; border:1px solid rgba(0,0,0,0.5);'></div>`,
                iconSize: [12, 12]
            });
            const marker = L.marker([p.lat, p.lng], {icon: icon});
            
            // POPUP HTML
            const popupHtml = `
                <div class="popup-content">
                    <b>ID: ${p.id}</b>
                    <div>–•–∞–±: ${p.assignedHub}</div>
                    <div style="font-size:1.1em; margin-bottom:5px;">–ì—Ä—É–ø–ø–∞: <b>${p.groupIndex}</b></div>
                    
                    <div class="popup-section">
                        <label>–ü–µ—Ä–µ–Ω–µ—Å—Ç–∏ —ç—Ç—É —Ç–æ—á–∫—É –≤:</label>
                        <div class="popup-row">
                            <input type="number" id="move-${p.id}" value="${p.groupIndex}" style="width:50px">
                            <button onclick="moveSinglePoint('${p.id}')">OK</button>
                        </div>
                    </div>

                    <div class="popup-section">
                        <label>üöÄ –°–ª–∏—Ç—å –≥—Ä—É–ø–ø—É ${p.groupIndex} —Å:</label>
                        <div class="popup-row">
                            <input type="number" id="merge-${p.id}" placeholder="‚Ññ" style="width:50px">
                            <button class="merge-btn" onclick="mergeWholeGroup('${p.id}')">–°–ª–∏—Ç—å</button>
                        </div>
                    </div>
                </div>
            `;
            marker.bindPopup(popupHtml);
            marker.addTo(layers.points);
        });
    }

    function drawBoundaries() {
        layers.polygons.clearLayers();
        layers.labels.clearLayers();
        
        const groups = {};
        // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —É–Ω–∏–∫–∞–ª—å–Ω–æ–º—É –∫–ª—é—á—É –•–∞–±+–ò–Ω–¥–µ–∫—Å
        pointsData.forEach(p => {
            if (!p.assignedHub || p.groupIndex === 0) return;
            const key = `${p.assignedHub}_${p.groupIndex}`;
            if (!groups[key]) groups[key] = { pts: [], color: p.color, idx: p.groupIndex };
            groups[key].pts.push([p.lng, p.lat]);
        });

        Object.values(groups).forEach(g => {
            if (g.pts.length < 1) return;
            const turfPts = turf.points(g.pts);
            
            // –ü–æ–ª–∏–≥–æ–Ω
            if (g.pts.length >= 3) {
                const hull = turf.convex(turfPts);
                if (hull) L.geoJSON(hull, { style: {color: g.color, weight: 2, fillOpacity: 0.2} }).addTo(layers.polygons);
            }

            // –ú–µ—Ç–∫–∞ –Ω–æ–º–µ—Ä–∞
            let center;
            if (g.pts.length >= 3) center = turf.centerOfMass(turf.convex(turfPts));
            else center = turf.center(turfPts);
            
            const c = center.geometry.coordinates;
            const label = L.divIcon({
                className: 'group-label',
                html: g.idx,
                iconSize: [20, 20], iconAnchor: [10, 10]
            });
            L.marker([c[1], c[0]], {icon: label, interactive: false}).addTo(layers.labels);
        });
    }

    function redrawMap() {
        drawPoints();
        drawBoundaries();
    }

    // --- –§—É–Ω–∫—Ü–∏–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è ---

    // 1. –ü–µ—Ä–µ–Ω–æ—Å –æ–¥–Ω–æ–π —Ç–æ—á–∫–∏
    window.moveSinglePoint = function(id) {
        const val = parseInt(document.getElementById(`move-${id}`).value);
        if (!val) return;
        const p = pointsData.find(x => x.id === id);
        if (p) {
            p.groupIndex = val;
            p.color = getColorForGroup(p.assignedHub, val); 
            map.closePopup();
            redrawMap();
        }
    };

    // 2. –°–ª–∏—è–Ω–∏–µ —Ü–µ–ª–æ–π –≥—Ä—É–ø–ø—ã
    window.mergeWholeGroup = function(clickedPointId) {
        const pSource = pointsData.find(x => x.id === clickedPointId);
        if (!pSource) return;

        const targetIndex = parseInt(document.getElementById(`merge-${clickedPointId}`).value);
        if (!targetIndex) return alert("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –≥—Ä—É–ø–ø—ã!");
        
        const sourceIndex = pSource.groupIndex;
        const hubId = pSource.assignedHub;

        if (sourceIndex === targetIndex) return alert("–≠—Ç–æ –æ–¥–Ω–∞ –∏ —Ç–∞ –∂–µ –≥—Ä—É–ø–ø–∞.");

        // –ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
        // if(!confirm(`–°–ª–∏—Ç—å –≥—Ä—É–ø–ø—É ${sourceIndex} –≤ –≥—Ä—É–ø–ø—É ${targetIndex}?`)) return;

        // –ù–∞—Ö–æ–¥–∏–º —Ü–≤–µ—Ç —Ü–µ–ª–µ–≤–æ–π –≥—Ä—É–ø–ø—ã (–µ—Å–ª–∏ –æ–Ω–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç)
        const targetColor = getColorForGroup(hubId, targetIndex);

        // –û–±–Ω–æ–≤–ª—è–µ–º –í–°–ï —Ç–æ—á–∫–∏ –∏—Å—Ö–æ–¥–Ω–æ–π –≥—Ä—É–ø–ø—ã
        let count = 0;
        pointsData.forEach(p => {
            if (p.assignedHub === hubId && p.groupIndex === sourceIndex) {
                p.groupIndex = targetIndex;
                p.color = targetColor;
                count++;
            }
        });

        alert(`–ü–µ—Ä–µ–Ω–µ—Å–µ–Ω–æ —Ç–æ—á–µ–∫: ${count}`);
        map.closePopup();
        redrawMap();
    };

    // –•–µ–ª–ø–µ—Ä: –Ω–∞–π—Ç–∏ —Ü–≤–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π –≥—Ä—É–ø–ø—ã –∏–ª–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—ã–π
    function getColorForGroup(hubId, groupIdx) {
        // –ò—â–µ–º –ª—é–±—É—é —Ç–æ—á–∫—É –∏–∑ —Ü–µ–ª–µ–≤–æ–π –≥—Ä—É–ø–ø—ã
        const existing = pointsData.find(p => p.assignedHub === hubId && p.groupIndex === groupIdx);
        if (existing) return existing.color;
        
        // –ï—Å–ª–∏ –≥—Ä—É–ø–ø—ã –Ω–µ—Ç - –≥–µ–Ω–µ—Ä–∏–º –Ω–æ–≤—ã–π —Ü–≤–µ—Ç –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ö—ç—à–∞ (—á—Ç–æ–±—ã –±—ã–ª —Å—Ç–∞–±–∏–ª—å–Ω—ã–º)
        return getDistinctColor((hubId.length + groupIdx) * 13);
    }

    // --- –≠–∫—Å–ø–æ—Ä—Ç ---
    function exportToExcel() {
        if (!pointsData.length) return;
        const ws = XLSX.utils.json_to_sheet(pointsData.map(p => ({
            "ID": p.id, "Lat": p.lat, "Lng": p.lng, "Hub": p.assignedHub, "Group": p.groupIndex
        })));
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Result");
        XLSX.writeFile(wb, "Distribution.xlsx");
    }

    // –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Ü–≤–µ—Ç–æ–≤ (–ó–æ–ª–æ—Ç–æ–π —É–≥–æ–ª)
    function getDistinctColor(index) {
        const hue = (index * 137.508) % 360; 
        return `hsl(${hue}, 70%, 45%)`;
    }
</script>

</body>
</html>