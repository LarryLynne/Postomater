<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü–æ—à—Ç–æ–º–∞—Ç–µ—Ä</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <style>
        :root {
            --bg-body: #0f172a;       
            --bg-sidebar: #1e293b;    
            --bg-card: #334155;       
            --bg-hover: #475569;      
            --text-main: #f1f5f9;     
            --text-muted: #94a3b8;
            --border: #334155;
        }

        body { 
            margin: 0; padding: 0; 
            font-family: 'Inter', sans-serif; 
            display: flex; height: 100vh; 
            color: var(--text-main);
            background: var(--bg-body);
        }
        
        /* SIDEBAR */
        #sidebar {
            width: 340px;
            flex-shrink: 0; 
            background: var(--bg-sidebar);
            padding: 20px; 
            border-right: 1px solid #1e293b;
            display: flex; flex-direction: column; gap: 15px; 
            box-shadow: 4px 0 15px rgba(0,0,0,0.3);
            z-index: 1000;
            overflow-y: auto; height: 100vh;
            box-sizing: border-box; 
        }

        h2 { 
            margin: 0; font-size: 1.1rem; 
            text-transform: uppercase; letter-spacing: 1.2px; color: var(--text-main); font-weight: 700;
        }

        .card {
            background: #1e293b;
            border: 1px solid var(--border);
            border-radius: 6px; padding: 15px;
        }

        label { 
            display: block; margin-bottom: 8px; 
            font-size: 0.75rem; color: var(--text-muted); 
            text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;
        }

        input[type="number"], input[type="file"] {
            width: 100%; box-sizing: border-box; padding: 10px;
            background: var(--bg-body); 
            border: 1px solid var(--border);
            color: var(--text-main); border-radius: 4px;
            font-family: inherit; outline: none;
            transition: border-color 0.2s;
        }
        input[type="number"]:focus { border-color: #64748b; }

        .file-wrapper {
            position: relative; overflow: hidden;
            background: var(--bg-body); border: 1px dashed var(--text-muted);
            border-radius: 4px; padding: 15px; text-align: center; cursor: pointer;
            transition: all 0.2s;
        }
        .file-wrapper:hover { border-color: var(--text-main); background: #182235; }
        .file-wrapper input { 
            position: absolute; top:0; left:0; width:100%; height:100%; opacity:0; cursor:pointer; 
        }
        #fileName { font-size: 0.85rem; color: var(--text-muted); pointer-events: none;}

        button {
            width: 100%; padding: 12px; margin-top: 10px;
            background-color: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-main);
            border-radius: 4px; cursor: pointer;
            font-size: 0.9rem; font-weight: 500;
            transition: all 0.2s;
            text-transform: uppercase; letter-spacing: 0.5px;
            line-height: 1.2;
        }
        button:hover { background-color: var(--bg-hover); border-color: #64748b; }
        button:active { transform: translateY(1px); }
        
        button:disabled {
            opacity: 0.5; cursor: not-allowed;
            background-color: #1e293b; color: #64748b;
        }
        
        button.small-btn { 
            margin-top: 0; padding: 6px 10px; 
            font-size: 0.75rem; width: auto; 
            background: #1e293b; 
        }

        .status { font-size: 0.8rem; color: var(--text-muted); margin-top: 10px; }
        .status-ok { color: #4ade80; } /* –ó–µ–ª–µ–Ω—ã–π –¥–ª—è —É—Å–ø–µ—Ö–∞ */

        #map { flex-grow: 1; height: 100%; background: #0f172a; }

        .leaflet-popup-content-wrapper, .leaflet-popup-tip {
            background: var(--bg-sidebar); color: var(--text-main);
            border: 1px solid var(--border);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .leaflet-popup-content { margin: 15px; line-height: 1.6; }
        .popup-row { display: flex; gap: 5px; margin-top: 8px; align-items: center; }
        
        .group-label {
            background: #747272b9; border: 2px solid var(--text-main);
            color: var(--text-main); border-radius: 50%;
            text-align: center; font-weight: bold; font-size: 12px; line-height: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .selected-marker {
            border: 2px solid #facc15 !important;
            transform: scale(1.3);
            box-shadow: 0 0 10px #facc15;
            z-index: 1000 !important;
        }

        #bulkActions {
            display: none;
            background: #334155; padding: 10px;
            border-radius: 4px; margin-top: 10px;
            border: 1px solid #facc15;
        }

        @media (max-width: 800px) {
            body { flex-direction: column; }
            #sidebar { width: 100%; height: 40vh; border-right: none; border-bottom: 1px solid #1e293b; }
            #map { width: 100%; height: 60vh; }
        }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #0f172a; border-radius: 4px; }
        ::-webkit-scrollbar-thumb { background-color: #334155; border-radius: 4px; border: 2px solid #0f172a; }
        ::-webkit-scrollbar-thumb:hover { background-color: #475569; }

        select {
            width: 100%; padding: 10px;
            background: var(--bg-body); border: 1px solid var(--border);
            color: var(--text-main); border-radius: 4px;
            cursor: pointer; margin-bottom: 5px;
        }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>–†–æ–∑–∫–∏–¥–∞—á –ø–æ—à—Ç–æ–º–∞—Ç—ñ–≤</h2>
    
    <div class="card">
        <label>1. –î–∞–Ω—ñ (.xlsx)</label>
        <div class="file-wrapper">
            <input type="file" id="fileInput" accept=".xlsx, .xls">
            <div id="fileName">–û–±—Ä–∞—Ç–∏ —Ñ–∞–π–ª</div>
        </div>
        <div id="fileStatus" class="status">–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è...</div>
    </div>

    <div class="card">
        <label>2. –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</label>
        
        <label style="margin-top:10px; margin-bottom:5px; color:#94a3b8;">–ê–ª–≥–æ—Ä–∏—Ç–º:</label>
        <select id="algoSelect">
            <option value="greedy">–°—É–≤–æ—Ä–∏–π –ª—ñ–º—ñ—Ç (–ñ–∞–¥—ñ–±–Ω–∏–π)</option>
            <option value="kmeans">–ë–∞–ª–∞–Ω—Å (K-Means)</option>
        </select>

        <div style="margin-bottom:5px; margin-top:10px; font-size:0.8rem; color:#94a3b8;">–ú–∞–∫—Å —Ç–æ—á–æ–∫ –Ω–∞ –≥—Ä—É–ø—É:</div>
        <input type="number" id="maxCapacity" value="50" min="1" step="5">
        
        <button onclick="calculateDistribution()">–ü—ñ–¥—Ä–∞—Ö—É–π</button>
    </div>

    <div class="card">
        <label>–Ü–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏</label>
        
        <button id="undoBtn" onclick="undoLastAction()" disabled style="background-color: #475569; border: 1px dashed #94a3b8; color: #f1f5f9;">
            ‚Ü© –°–∫–∞—Å—É–≤–∞—Ç–∏ –¥—ñ—é
        </button>

        <hr style="border-color:#334155; margin: 15px 0;">

        <button id="btnSelectMode" onclick="toggleSelectionMode()">–ú–∞—Å–æ–≤–µ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è</button>
        
        <div id="bulkActions">
            <label style="color:#facc15;">–û–±—Ä–∞–Ω–æ —Ç–æ—á–æ–∫: <span id="selCount">0</span></label>
            <div style="margin-bottom:5px; font-size:0.75rem;">–ù–æ–≤–∞ –≥—Ä—É–ø–∞:</div>
            <div style="display:flex; gap:5px;">
                <input type="number" id="bulkGroupInput" placeholder="‚Ññ" style="width: 60px;" min="-50">
                <button class="small-btn" onclick="moveSelectedPoints()" style="background:#0f172a;">OK</button>
            </div>
            <button class="small-btn" onclick="clearSelection()" style="width:100%; margin-top:5px; border-color: #ef4444; color:#ef4444;">–°–∫–∞—Å—É–≤–∞—Ç–∏ –≤–∏–±—ñ—Ä</button>
        </div>

        <button onclick="redrawMap()" style="margin-top:15px">–û–Ω–æ–≤–∏—Ç–∏ –º–∞–ø—É</button>
        <button onclick="exportToExcel()" style="border-color: #4ade80; color: #4ade80;">üíæ –ó–±–µ—Ä–µ–≥—Ç–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç</button>
    </div>
    
</div>

<div id="map"></div>

<script>
    let map;
    let hubsData = [];
    let pointsData = [];
    let layers = {
        hubs: L.layerGroup(),
        points: L.layerGroup(),
        polygons: L.layerGroup(),
        labels: L.layerGroup()
    };
    let selectionMode = false;
    let selectedIds = new Set();
    let historyStack = [];
    const MAX_HISTORY = 20;

    function initMap() {
        map = L.map('map', {zoomControl: false}).setView([50.4501, 30.5234], 11);
        L.control.zoom({ position: 'topright' }).addTo(map);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '¬© OpenStreetMap' }).addTo(map);
        layers.polygons.addTo(map);
        layers.hubs.addTo(map);
        layers.points.addTo(map);
        layers.labels.addTo(map);
    }
    initMap();

    // --- SAVE / RESTORE / LOAD ---
    
    document.getElementById('fileInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            document.getElementById('fileName').innerText = file.name;
            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const wb = XLSX.read(data, {type: 'array'});
                
                // 1. –ü–†–û–í–ï–†–Ø–ï–ú, –≠–¢–û –§–ê–ô–õ –° –°–û–•–†–ê–ù–ï–ù–ò–ï–ú –ò–õ–ò –ù–û–í–´–ô?
                if (wb.SheetNames.includes("Saved_Points") && wb.SheetNames.includes("Saved_Hubs")) {
                    restoreWork(wb);
                } else {
                    parseNewFile(wb);
                }
            };
            reader.readAsArrayBuffer(file);
        }
    });

    // –í–µ—Ç–∫–∞ "–ù–æ–≤—ã–π —Ñ–∞–π–ª"
    function parseNewFile(wb) {
        const names = wb.SheetNames;
        // –≠–≤—Ä–∏—Å—Ç–∏–∫–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞ –ª–∏—Å—Ç–æ–≤
        let hName = names.find(n => n.toLowerCase().includes('—Å–ª—É–∂–±') || n.toLowerCase().includes('hubs')) || names[0];
        let pName = names.find(n => n.toLowerCase().includes('–ø–æ—à—Ç') || n.toLowerCase().includes('points')) || names[1] || names[0];

        const hRaw = XLSX.utils.sheet_to_json(wb.Sheets[hName]);
        const pRaw = XLSX.utils.sheet_to_json(wb.Sheets[pName]);
        
        processData(hRaw, pRaw, false); // false = not restored
    }

    // –í–µ—Ç–∫–∞ "–í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã"
    function restoreWork(wb) {
        const hRaw = XLSX.utils.sheet_to_json(wb.Sheets["Saved_Hubs"]);
        const pRaw = XLSX.utils.sheet_to_json(wb.Sheets["Saved_Points"]);
        
        // –ú–∞–ø–ø–∏–Ω–≥ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (—Ç–∞–º –∫–ª—é—á–∏ —É–∂–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ eng)
        hubsData = hRaw.map(h => ({
            id: h.id, lat: h.lat, lng: h.lng
        }));
        
        pointsData = pRaw.map(p => ({
            id: p.id, lat: p.lat, lng: p.lng,
            assignedHub: p.assignedHub, 
            groupIndex: p.groupIndex, 
            color: p.color
        }));

        historyStack = [];
        updateUndoUI();

        // –†–∏—Å—É–µ–º —Å—Ä–∞–∑—É, –±–µ–∑ –ø–µ—Ä–µ—Å—á–µ—Ç–∞
        drawHubs();
        drawPoints();
        drawBoundaries();

        const statusEl = document.getElementById('fileStatus');
        statusEl.innerHTML = "–†–æ–±–æ—Ç—É –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–æ! <span class='status-ok'>‚úî Saved_Points found</span>";
        statusEl.classList.add('status-ok');
    }

    function processData(hRaw, pRaw, isRestored) {
        if(!isRestored) {
            hubsData = hRaw.filter(r => r['–®–∏—Ä–æ—Ç–∞']).map(h => ({
                id: h['–°–∫–ª–∞–¥'] || h['–ù–∞–∑–≤–∞–Ω–∏–µ'] || h['ID'] || 'Unknown',
                lat: parseFloat(h['–®–∏—Ä–æ—Ç–∞']), lng: parseFloat(h['–î–æ–≤–≥–æ—Ç–∞'])
            }));
            pointsData = pRaw.filter(r => r['–®–∏—Ä–æ—Ç–∞']).map(p => ({
                id: p['–°–∫–ª–∞–¥'] || p['ID'] || 'Unknown',
                lat: parseFloat(p['–®–∏—Ä–æ—Ç–∞']), lng: parseFloat(p['–î–æ–≤–≥–æ—Ç–∞']),
                assignedHub: null, groupIndex: 0, color: '#475569'
            }));
        }
        
        historyStack = [];
        updateUndoUI();

        document.getElementById('fileStatus').innerText = `–°–î: ${hubsData.length} | –ü–æ—à—Ç–æ–º–∞—Ç–∏: ${pointsData.length}`;
        document.getElementById('fileStatus').classList.remove('status-ok');
        
        drawHubs();
        drawPoints();
    }

    function calculateDistribution() {
        if(!hubsData.length) return alert('–ó–∞–≤–∞–Ω—Ç–∞–∂—Ç–µ —Ñ–∞–π–ª!');
        saveState(); 

        const max = parseInt(document.getElementById('maxCapacity').value) || 50;
        const algo = document.getElementById('algoSelect').value;

        // –ü—Ä–∏–≤—è–∑–∫–∞
        pointsData.forEach(p => {
            let nearest = null, min = Infinity;
            const pt = turf.point([p.lng, p.lat]);
            hubsData.forEach(h => {
                const d = turf.distance(pt, turf.point([h.lng, h.lat]));
                if(d < min) { min = d; nearest = h.id; }
            });
            p.assignedHub = nearest;
            p.groupIndex = 0; 
        });

        // –ê–ª–≥–æ—Ä–∏—Ç–º—ã
        hubsData.forEach(h => {
            let hubPoints = pointsData.filter(p => p.assignedHub === h.id);
            if (!hubPoints.length) return;
            if (algo === 'greedy') applyGreedyAlgo(h, hubPoints, max);
            else applyKMeansAlgo(h, hubPoints, max);
        });
        redrawMap();
    }

    // --- ALGORITHMS ---
    function applyKMeansAlgo(hub, pts, max) {
        const k = Math.ceil(pts.length / max);
        if(k <= 1) {
            const col = getDistinctColor(1);
            pts.forEach(p => { p.groupIndex = 1; p.color = col; });
        } else {
            const fc = turf.featureCollection(pts.map(p => turf.point([p.lng, p.lat], {oid: p.id})));
            const clustered = turf.clustersKmeans(fc, {numberOfClusters: k});
            const mapCol = {}; let localC = 0;
            clustered.features.forEach(f => {
                const cid = f.properties.cluster; 
                if(!mapCol[cid]) { localC++; mapCol[cid] = getDistinctColor((hub.id.length + localC) * 5); }
                const p = pts.find(x => x.id === f.properties.oid);
                if(p) { p.groupIndex = cid + 1; p.color = mapCol[cid]; }
            });
        }
    }

    function applyGreedyAlgo(hub, pts, max) {
        let pool = [...pts]; let gCounter = 1;
        const hubPt = turf.point([hub.lng, hub.lat]);
        while(pool.length > 0) {
            if(pool.length <= max) {
                const col = getDistinctColor((hub.id.length + gCounter) * 7);
                pool.forEach(p => { p.groupIndex = gCounter; p.color = col; });
                break;
            }
            let farthestPt = pool[0]; let maxDist = -1;
            pool.forEach(p => {
                const d = turf.distance(hubPt, turf.point([p.lng, p.lat]));
                if(d > maxDist) { maxDist = d; farthestPt = p; }
            });
            const anchorGeo = turf.point([farthestPt.lng, farthestPt.lat]);
            const withDist = pool.map(p => ({ p: p, d: turf.distance(anchorGeo, turf.point([p.lng, p.lat])) }));
            withDist.sort((a, b) => a.d - b.d);
            const chunk = withDist.slice(0, max).map(x => x.p);
            const chunkIds = new Set(chunk.map(x => x.id));
            const col = getDistinctColor((hub.id.length + gCounter) * 7);
            chunk.forEach(p => { p.groupIndex = gCounter; p.color = col; });
            pool = pool.filter(p => !chunkIds.has(p.id));
            gCounter++;
        }
    }

    // --- DRAWING ---
    function drawHubs() {
        layers.hubs.clearLayers();
        const icon = L.divIcon({
            className: '',
            html: "<div style='background:#0f172a; color:#fff; width:24px; height:24px; border-radius:50%; display:flex; align-items:center; justify-content:center; border:2px solid #fff; font-weight:bold;'>H</div>",
            iconSize: [28,28]
        });
        hubsData.forEach(h => L.marker([h.lat, h.lng], {icon}).addTo(layers.hubs));
    }

    function drawPoints() {
        layers.points.clearLayers();
        pointsData.forEach(p => {
            const isSelected = selectedIds.has(p.id);
            const extraClass = isSelected ? 'selected-marker' : '';
            const icon = L.divIcon({
                className: '', 
                html: `<div class="pt-marker ${extraClass}" id="marker-${p.id}" style='background:${p.color}; width:10px; height:10px; border-radius:50%; border:1px solid #1e293b; transition:all 0.1s;'></div>`,
                iconSize: [12,12]
            });
            const m = L.marker([p.lat, p.lng], {icon});
            m.on('click', function(e) {
                if (selectionMode) togglePointSelection(p.id);
                else {
                    const popupContent = `
                        <b>${p.id}</b><br>
                        –°–î: ${p.assignedHub}<br>
                        –ì—Ä—É–ø–∞: <span style='font-size:1.2em; font-weight:bold'>${p.groupIndex}</span>
                        <hr style="border-color:#334155; margin:8px 0;">
                        <div class="popup-row">
                            <input type="number" id="m-${p.id}" value="${p.groupIndex}" style="width:60px">
                            <button class="small-btn" onclick="movePt('${p.id}')">OK</button>
                        </div>
                        <div class="popup-row" style="margin-top:8px">
                            <input type="number" id="mg-${p.id}" placeholder="‚Ññ" style="width:60px">
                            <button class="small-btn" onclick="mergeGr('${p.id}')">–ü–æ—î–¥–Ω–∞—Ç–∏</button>
                        </div>`;
                    L.popup().setLatLng(e.latlng).setContent(popupContent).openOn(map);
                }
            });
            m.addTo(layers.points);
        });
    }

    function drawBoundaries() {
        layers.polygons.clearLayers(); layers.labels.clearLayers();
        const gr = {};
        pointsData.forEach(p => {
            if(!p.assignedHub) return;
            const k = p.assignedHub + '_' + p.groupIndex;
            if(!gr[k]) gr[k] = {pts:[], c:p.color, i:p.groupIndex};
            gr[k].pts.push([p.lng, p.lat]);
        });
        Object.values(gr).forEach(g => {
            if(g.pts.length < 1) return;
            const tp = turf.points(g.pts);
            if(g.pts.length >= 3) {
                const hull = turf.convex(tp);
                if(hull) L.geoJSON(hull, {style: {color:g.c, weight:2, fillOpacity:0.3}}).addTo(layers.polygons);
            }
            let cent = (g.pts.length>=3) ? turf.centerOfMass(turf.convex(tp)) : turf.center(tp);
            const cc = cent.geometry.coordinates;
            const icon = L.divIcon({ className: 'group-label', html: g.i, iconSize:[20,20], iconAnchor:[10,10] });
            L.marker([cc[1], cc[0]], {icon, interactive:false}).addTo(layers.labels);
        });
    }

    function redrawMap() { drawPoints(); drawBoundaries(); }

    // --- ACTIONS & UNDO ---
    function saveState() {
        const snapshot = JSON.parse(JSON.stringify(pointsData));
        historyStack.push(snapshot);
        if (historyStack.length > MAX_HISTORY) historyStack.shift();
        updateUndoUI();
    }

    window.undoLastAction = function() {
        if (historyStack.length === 0) return;
        const prevState = historyStack.pop();
        pointsData = prevState;
        clearSelection(); 
        redrawMap();
        updateUndoUI();
    };

    function updateUndoUI() {
        const btn = document.getElementById('undoBtn');
        if (historyStack.length > 0) {
            btn.disabled = false; btn.style.opacity = '1';
            btn.innerText = `‚Ü© –°–∫–∞—Å—É–≤–∞—Ç–∏ –¥—ñ—é (${historyStack.length})`;
        } else {
            btn.disabled = true; btn.style.opacity = '0.5';
            btn.innerText = `‚Ü© –°–∫–∞—Å—É–≤–∞—Ç–∏ –¥—ñ—é`;
        }
    }

    window.movePt = function(id) {
        const val = parseInt(document.getElementById('m-'+id).value);
        const p = pointsData.find(x => x.id === id);
        if(p && val) {
            saveState();
            p.groupIndex = val;
            p.color = getColor(p.assignedHub, val);
            map.closePopup(); redrawMap();
        }
    };
    
    window.mergeGr = function(id) {
        const pSrc = pointsData.find(x => x.id === id);
        const tIdx = parseInt(document.getElementById('mg-'+id).value);
        if(pSrc && tIdx && pSrc.groupIndex !== tIdx) {
            saveState();
            const tCol = getColor(pSrc.assignedHub, tIdx);
            const sHub = pSrc.assignedHub; const sGrp = pSrc.groupIndex;
            pointsData.forEach(p => {
                if(p.assignedHub === sHub && p.groupIndex === sGrp) {
                    p.groupIndex = tIdx; p.color = tCol;
                }
            });
            map.closePopup(); redrawMap();
        }
    };

    function getColor(hid, gidx) {
        const ex = pointsData.find(p => p.assignedHub === hid && p.groupIndex === gidx);
        return ex ? ex.color : getDistinctColor((hid.length+gidx)*13);
    }
    
    function getDistinctColor(i) { return `hsl(${(i * 137.5) % 360}, 75%, 55%)`; }

    // --- EXPORT WITH SAVED STATE ---
    function exportToExcel() {
        if(!pointsData.length) return;
        
        // 1. –õ–∏—Å—Ç —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –¥–ª—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞/–≤–æ–¥–∏—Ç–µ–ª—è (–ø—Ä–æ—Å—Ç–æ–π)
        const wsExport = XLSX.utils.json_to_sheet(pointsData.map(p => ({
            "ID":p.id, "Lat":p.lat, "Lng":p.lng, "Hub":p.assignedHub, "Group":p.groupIndex
        })));

        // 2. –õ–∏—Å—Ç –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–æ—Å—Ç–æ—è–Ω–∏—è —Ç–æ—á–µ–∫ (—Å–æ –≤—Å–µ–º–∏ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏–º–∏ –¥–∞–Ω–Ω—ã–º–∏)
        const wsSavedPoints = XLSX.utils.json_to_sheet(pointsData.map(p => ({
            id: p.id, lat: p.lat, lng: p.lng,
            assignedHub: p.assignedHub, groupIndex: p.groupIndex, color: p.color
        })));

        // 3. –õ–∏—Å—Ç –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ö–∞–±–æ–≤ (—á—Ç–æ–±—ã –Ω–µ –Ω—É–∂–µ–Ω –±—ã–ª –∏—Å—Ö–æ–¥–Ω–∏–∫)
        const wsSavedHubs = XLSX.utils.json_to_sheet(hubsData);

        const wb = XLSX.utils.book_new();
        
        // –î–æ–±–∞–≤–ª—è–µ–º –ª–∏—Å—Ç—ã
        XLSX.utils.book_append_sheet(wb, wsExport, "Result_Export");
        XLSX.utils.book_append_sheet(wb, wsSavedPoints, "Saved_Points"); // <--- –ú–µ—Ç–∫–∞ –¥–ª—è —Å–∏—Å—Ç–µ–º—ã
        XLSX.utils.book_append_sheet(wb, wsSavedHubs, "Saved_Hubs");

        // –§–æ—Ä–º–∏—Ä—É–µ–º –∏–º—è —Ñ–∞–π–ª–∞ —Å –¥–∞—Ç–æ–π
        const date = new Date().toISOString().slice(0,10);
        XLSX.writeFile(wb, `Routes_${date}.xlsx`);
    }

    // --- BULK TOOLS ---
    function toggleSelectionMode() {
        selectionMode = !selectionMode;
        const btn = document.getElementById('btnSelectMode');
        const panel = document.getElementById('bulkActions');
        if (selectionMode) {
            btn.style.background = '#facc15'; btn.style.color = '#000';
            btn.innerText = '–ú–∞—Å–æ–≤–µ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è (–í–∏–º–∫–Ω—É—Ç–∏)';
            panel.style.display = 'block';
        } else {
            btn.style.background = ''; btn.style.color = '';
            btn.innerText = '–ú–∞—Å–æ–≤–µ –ø–µ—Ä–µ–º—ñ—â–µ–Ω–Ω—è';
            if(selectedIds.size === 0) panel.style.display = 'none';
        }
    }

    function togglePointSelection(id) {
        const el = document.getElementById('marker-' + id);
        if (selectedIds.has(id)) {
            selectedIds.delete(id);
            if(el) el.classList.remove('selected-marker');
        } else {
            selectedIds.add(id);
            if(el) el.classList.add('selected-marker');
        }
        document.getElementById('selCount').innerText = selectedIds.size;
    }

    function clearSelection() {
        selectedIds.clear();
        document.getElementById('selCount').innerText = 0;
        document.querySelectorAll('.selected-marker').forEach(el => el.classList.remove('selected-marker'));
        if(selectionMode) toggleSelectionMode();
        document.getElementById('bulkActions').style.display = 'none';
    }

    window.moveSelectedPoints = function() {
        const targetGroup = parseInt(document.getElementById('bulkGroupInput').value);
        if (!targetGroup && targetGroup !== 0) return alert("–í–∫–∞–∂—ñ—Ç—å –Ω–æ–º–µ—Ä –≥—Ä—É–ø–∏!");
        if (selectedIds.size === 0) return alert("–û–±–µ—Ä—ñ—Ç—å —Ç–æ—á–∫–∏!");

        saveState();
        const colorCache = {};
        pointsData.forEach(p => {
            if (!selectedIds.has(p.id)) return;
            const hub = p.assignedHub; const key = hub + '_' + targetGroup;
            if (!colorCache[key]) {
                const existingPoint = pointsData.find(ex => ex.assignedHub === hub && ex.groupIndex === targetGroup && !selectedIds.has(ex.id));
                colorCache[key] = existingPoint ? existingPoint.color : getDistinctColor((hub.length + targetGroup) * 13);
            }
            p.groupIndex = targetGroup; p.color = colorCache[key];
        });
        clearSelection(); 
        document.getElementById('bulkGroupInput').value = '';
        redrawMap();
    };

    document.querySelectorAll('#maxCapacity, #bulkGroupInput').forEach(input => {
        input.addEventListener('wheel', function(e) {
            e.preventDefault();
            const step = parseInt(this.getAttribute('step')) || 1;
            const direction = e.deltaY < 0 ? 1 : -1;
            this.value = (parseInt(this.value) || 0) + (step * direction);
        }, { passive: false });
    });
</script>
</body>
</html>