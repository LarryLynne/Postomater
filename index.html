<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Поштоматер</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>

    <style>
        :root {
            /* Палитра темной темы */
            --bg-body: #0f172a;       /* Глубокий темный фон */
            --bg-sidebar: #1e293b;    /* Панель */
            --bg-card: #334155;       /* Карточки/Кнопки */
            --bg-hover: #475569;      /* Ховер кнопок */
            --text-main: #f1f5f9;     
            --text-muted: #94a3b8;
            --border: #334155;
        }

        body { 
            margin: 0; padding: 0; 
            font-family: 'Inter', sans-serif; 
            display: flex; height: 100vh; 
            color: var(--text-main);
            background: var(--bg-body);
        }
        
        /* SIDEBAR */
        #sidebar {
            width: 340px;
            /* Запрещаем панели сжиматься, если места мало */
            flex-shrink: 0; 
            
            background: var(--bg-sidebar);
            padding: 20px; /* Чуть уменьшим отступы для компактности */
            border-right: 1px solid #1e293b;
            display: flex; 
            flex-direction: column; 
            gap: 15px; /* Чуть плотнее элементы */
            box-shadow: 4px 0 15px rgba(0,0,0,0.3);
            z-index: 1000;
            
            /* САМОЕ ВАЖНОЕ: Если контента много, появится скролл */
            overflow-y: auto; 
            height: 100vh;
            box-sizing: border-box; /* Чтобы padding не ломал ширину */
        }

        /* --- БЛОК ЛОГОТИПА (PNG) --- */
        .logo-branding {
            display: flex;
            flex-direction: column;
            align-items: center;     /* Центрирование по горизонтали */
            /*margin-top: 50px;*/
            /*margin-bottom: 10px;*/
            /*padding-bottom: 20px;*/
            /*border-bottom: 1px solid var(--border);*/
            text-align: center;
            
        }

        /* Стиль для картинки logo.png */
        .brand-logo {
            max-width: 90%;       /* Чтобы не вылезала за края, если большая */
            max-height: 100px;     /* Ограничение высоты, чтобы не сдвигать меню */
            margin-bottom: 30px;  /* Отступ до текста */
            display: block;
        }
        
        h2 { 
            margin: 0; font-size: 1.1rem; 
            text-transform: uppercase; letter-spacing: 1.2px; color: var(--text-main); font-weight: 700;
        }
        /* --------------------------- */

        .card {
            background: #1e293b;
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 15px;
        }

        label { 
            display: block; margin-bottom: 8px; 
            font-size: 0.75rem; color: var(--text-muted); 
            text-transform: uppercase; letter-spacing: 0.5px; font-weight: 600;
        }

        /* Единый стиль инпутов */
        input[type="number"], input[type="file"] {
            width: 100%; box-sizing: border-box; padding: 10px;
            background: var(--bg-body); 
            border: 1px solid var(--border);
            color: var(--text-main); border-radius: 4px;
            font-family: inherit; outline: none;
            transition: border-color 0.2s;
        }
        input[type="number"]:focus { border-color: #64748b; }

        /* File Upload Styling */
        .file-wrapper {
            position: relative; overflow: hidden;
            background: var(--bg-body); border: 1px dashed var(--text-muted);
            border-radius: 4px; padding: 15px; text-align: center; cursor: pointer;
            transition: all 0.2s;
        }
        .file-wrapper:hover { border-color: var(--text-main); background: #182235; }
        .file-wrapper input { 
            position: absolute; top:0; left:0; width:100%; height:100%; opacity:0; cursor:pointer; 
        }
        #fileName { font-size: 0.85rem; color: var(--text-muted); pointer-events: none;}

        /* --- КНОПКИ (ЕДИНЫЙ ТЕМНЫЙ СТИЛЬ) --- */
        button {
            width: 100%; padding: 12px; margin-top: 10px;
            background-color: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-main);
            border-radius: 4px; cursor: pointer;
            font-size: 0.9rem; font-weight: 500;
            transition: all 0.2s;
            text-transform: uppercase; letter-spacing: 0.5px;
            white-space: normal; 
            word-wrap: break-word; 
            line-height: 1.2;
        }
        button:hover { 
            background-color: var(--bg-hover);
            border-color: #64748b;
        }
        button:active { transform: translateY(1px); }
        
        button.small-btn { 
            margin-top: 0; padding: 6px 10px; 
            font-size: 0.75rem; width: auto; 
            background: #1e293b; 
        }

        .status { font-size: 0.8rem; color: var(--text-muted); margin-top: 10px; }

        /* MAP & POPUPS */
        #map { flex-grow: 1; height: 100%; background: #0f172a; }

        .leaflet-popup-content-wrapper, .leaflet-popup-tip {
            background: var(--bg-sidebar);
            color: var(--text-main);
            border: 1px solid var(--border);
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .leaflet-popup-content { margin: 15px; line-height: 1.6; }
        .popup-row { display: flex; gap: 5px; margin-top: 8px; align-items: center; }
        
        /* Маркер номера */
        .group-label {
            background: #747272b9;
            border: 2px solid var(--text-main);
            color: var(--text-main);
            border-radius: 50%;
            text-align: center; font-weight: bold; font-size: 12px; line-height: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        .selected-marker {
            border: 2px solid #facc15 !important; /* Желтый яркий */
            transform: scale(1.3);
            box-shadow: 0 0 10px #facc15;
            z-index: 1000 !important;
        }

        /* Скрытый блок действий с выделенными */
        #bulkActions {
            display: none; /* Скрыт по умолчанию */
            background: #334155;
            padding: 10px;
            border-radius: 4px;
            margin-top: 10px;
            border: 1px solid #facc15;
        }
        @media (max-width: 800px) {
            body {
                flex-direction: column; /* Элементы встают друг под друга */
            }

            #sidebar {
                width: 100%;       /* Панель на всю ширину */
                height: 40vh;      /* Высота 40% от экрана */
                min-height: 300px;
                border-right: none;
                border-bottom: 1px solid #1e293b;
                flex-shrink: 0;
            }

            #map {
                width: 100%;
                height: 60vh; /* Карта занимает остальное */
                flex-grow: 1;
            }
        }
        /* --- СТИЛИЗАЦИЯ ПОЛОСЫ ПРОКРУТКИ (SCROLLBAR) --- */

        /* Для Webkit-браузеров (Chrome, Edge, Safari) */
        ::-webkit-scrollbar {
            width: 8px;               /* Ширина вертикального скролла */
            height: 8px;              /* Высота горизонтального (если появится) */
        }

        /* Фон под ползунком (трек) */
        ::-webkit-scrollbar-track {
            background: #0f172a;      /* Темный цвет, как фон карты/body */
            border-radius: 4px;
        }

        /* Сам ползунок */
        ::-webkit-scrollbar-thumb {
            background-color: #334155; /* Цвет карточек */
            border-radius: 4px;        /* Закругленные края */
            border: 2px solid #0f172a; /* Отступ от края трека (создает эффект тонкости) */
        }

        /* Ползунок при наведении мыши */
        ::-webkit-scrollbar-thumb:hover {
            background-color: #475569; /* Светлеет при наведении (как кнопки) */
        }

        /* Для Firefox (у него свой стандарт) */
        * {
            scrollbar-width: thin;           /* Тонкий скролл */
            scrollbar-color: #334155 #0f172a; /* Цвет ползунка и фона */
        }
        /* Стиль для выпадающего списка */
        select {
            width: 100%; box-sizing: border-box; padding: 10px;
            background: var(--bg-body); 
            border: 1px solid var(--border);
            color: var(--text-main); border-radius: 4px;
            font-family: inherit; outline: none;
            cursor: pointer;
            margin-bottom: 5px;
        }
        select:focus { border-color: #64748b; }
    </style>
</head>
<body>

<div id="sidebar">
    <h2>Розкидач поштоматів</h2>
    <!--<div class="logo-branding">
        <img src="logo.png" alt="Logo" class="brand-logo" onerror="this.style.display='none'">
    </div> -->
    
    <div class="card">
        <label>1. Дані (.xlsx)</label>
        <div class="file-wrapper">
            <input type="file" id="fileInput" accept=".xlsx, .xls">
            <div id="fileName">Обрати файл</div>
        </div>
        <div id="fileStatus" class="status">Очікування завантаження...</div>
    </div>

    <div class="card">
        <label>2. Налаштування</label>
        
        <label style="margin-top:10px; margin-bottom:5px; color:#94a3b8;">Алгоритм:</label>
        <select id="algoSelect">
            <option value="greedy">Суворий ліміт (Жадібний)</option>
            <option value="kmeans">Баланс (K-Means)</option>
        </select>

        <div style="margin-bottom:5px; margin-top:10px; font-size:0.8rem; color:#94a3b8;">Макс точок на групу:</div>
        <input type="number" id="maxCapacity" value="50" min="1" step="5">
        
        <button onclick="calculateDistribution()">Підрахуй</button>
    </div>

    <div class="card">
        <label>Інструменти</label>
        
        <button id="btnSelectMode" onclick="toggleSelectionMode()">Масове переміщення</button>
        
        <div id="bulkActions">
            <label style="color:#facc15;">Обрано точок: <span id="selCount">0</span></label>
            <div style="margin-bottom:5px; font-size:0.75rem;">Нова група:</div>
            <div style="display:flex; gap:5px;">
                <input type="number" id="bulkGroupInput" placeholder="№" style="width: 60px;" min="-50">
                <button class="small-btn" onclick="moveSelectedPoints()" style="background:#0f172a;">OK</button>
            </div>
            <button class="small-btn" onclick="clearSelection()" style="width:100%; margin-top:5px; border-color: #ef4444; color:#ef4444;">Скасувати вибір</button>
        </div>

        <hr style="border-color:#334155; margin: 15px 0;">
        <button onclick="redrawMap()">Оновити мапу</button>
        <button onclick="exportToExcel()">Скачати Excel</button>
    </div>
    
</div>

<div id="map"></div>

<script>
    // --- ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ ---
    let map;
    let hubsData = [];
    let pointsData = [];
    let layers = {
        hubs: L.layerGroup(),
        points: L.layerGroup(),
        polygons: L.layerGroup(),
        labels: L.layerGroup()
    };
    let selectionMode = false;
    let selectedIds = new Set(); // Хранит ID выбранных точек

    // --- ИНИЦИАЛИЗАЦИЯ ---
    function initMap() {
        map = L.map('map', {zoomControl: false}).setView([50.4501, 30.5234], 11);
        L.control.zoom({ position: 'topright' }).addTo(map);
        
        // OSM
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap'
        }).addTo(map);

        layers.polygons.addTo(map);
        layers.hubs.addTo(map);
        layers.points.addTo(map);
        layers.labels.addTo(map);
    }
    initMap();

    // --- ЗАГРУЗКА ---
    document.getElementById('fileInput').addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file) {
            document.getElementById('fileName').innerText = file.name;
            const reader = new FileReader();
            reader.onload = function(e) {
                const data = new Uint8Array(e.target.result);
                const wb = XLSX.read(data, {type: 'array'});
                
                const names = wb.SheetNames;
                let hName = names.find(n => n.toLowerCase().includes('служб')) || names[0];
                let pName = names.find(n => n.toLowerCase().includes('пошт') || n.toLowerCase().includes('почт')) || names[1] || names[0];

                const hRaw = XLSX.utils.sheet_to_json(wb.Sheets[hName]);
                const pRaw = XLSX.utils.sheet_to_json(wb.Sheets[pName]);
                processData(hRaw, pRaw);
            };
            reader.readAsArrayBuffer(file);
        }
    });

    function processData(hRaw, pRaw) {
        hubsData = hRaw.filter(r => r['Широта']).map(h => ({
            id: h['Склад'] || h['Название'] || 'Unknown',
            lat: parseFloat(h['Широта']), lng: parseFloat(h['Довгота'])
        }));
        pointsData = pRaw.filter(r => r['Широта']).map(p => ({
            id: p['Склад'] || p['ID'] || 'Unknown',
            lat: parseFloat(p['Широта']), lng: parseFloat(p['Довгота']),
            assignedHub: null, groupIndex: 0, color: '#475569'
        }));
        
        document.getElementById('fileStatus').innerText = `СД: ${hubsData.length} | Поштомати: ${pointsData.length}`;
        drawHubs();
        drawPoints();
    }

    // --- ЛОГИКА ---
    function calculateDistribution() {
        if(!hubsData.length) return alert('Завантажте файл!');
        
        const max = parseInt(document.getElementById('maxCapacity').value) || 50;
        const algo = document.getElementById('algoSelect').value;

        // 1. Сначала привязываем все точки к ближайшим хабам (общий шаг)
        pointsData.forEach(p => {
            let nearest = null, min = Infinity;
            const pt = turf.point([p.lng, p.lat]);
            hubsData.forEach(h => {
                const d = turf.distance(pt, turf.point([h.lng, h.lat]));
                if(d < min) { min = d; nearest = h.id; }
            });
            p.assignedHub = nearest;
            p.groupIndex = 0; // Сброс
        });

        // 2. Запускаем выбранный алгоритм для каждого хаба
        hubsData.forEach(h => {
            // Берем точки только этого хаба
            let hubPoints = pointsData.filter(p => p.assignedHub === h.id);
            if (!hubPoints.length) return;

            if (algo === 'greedy') {
                applyGreedyAlgo(h, hubPoints, max);
            } else {
                applyKMeansAlgo(h, hubPoints, max);
            }
        });

        redrawMap();
    }

    // --- АЛГОРИТМ 1: K-MEANS (Геометрический/Баланс) ---
    function applyKMeansAlgo(hub, pts, max) {
        // Вычисляем, сколько нужно групп (округляем вверх)
        const k = Math.ceil(pts.length / max);
        
        if(k <= 1) {
            // Если все влезают в одну группу
            const col = getDistinctColor(1);
            pts.forEach(p => { p.groupIndex = 1; p.color = col; });
        } else {
            // Turf.js K-Means
            const fc = turf.featureCollection(pts.map(p => turf.point([p.lng, p.lat], {oid: p.id})));
            const clustered = turf.clustersKmeans(fc, {numberOfClusters: k});
            
            // Карта цветов для кластеров
            const mapCol = {};
            let localC = 0;

            clustered.features.forEach(f => {
                const cid = f.properties.cluster; // 0, 1, 2...
                // Генерируем цвет, если еще нет
                if(!mapCol[cid]) { 
                    localC++; 
                    // Делаем уникальный цвет, зависящий от названия хаба, чтобы соседние хабы не сливались
                    mapCol[cid] = getDistinctColor((hub.id.length + localC) * 5); 
                }
                
                const p = pts.find(x => x.id === f.properties.oid);
                if(p) { 
                    p.groupIndex = cid + 1; // Делаем группы с 1, а не с 0
                    p.color = mapCol[cid]; 
                }
            });
        }
    }

    // --- АЛГОРИТМ 2: GREEDY (Строгий лимит) ---
    function applyGreedyAlgo(hub, pts, max) {
        let pool = [...pts]; // Копия массива, чтобы "откусывать" от него
        let gCounter = 1;
        const hubPt = turf.point([hub.lng, hub.lat]);

        while(pool.length > 0) {
            // Если остаток меньше лимита — это последняя группа
            if(pool.length <= max) {
                const col = getDistinctColor((hub.id.length + gCounter) * 7);
                pool.forEach(p => { 
                    p.groupIndex = gCounter; 
                    p.color = col; 
                });
                break;
            }

            // А. Ищем самую дальнюю точку от Склада (чтобы идти от краев)
            let farthestPt = pool[0];
            let maxDist = -1;
            pool.forEach(p => {
                const d = turf.distance(hubPt, turf.point([p.lng, p.lat]));
                if(d > maxDist) { maxDist = d; farthestPt = p; }
            });

            // Б. Находим (max-1) ближайших соседей к этой дальней точке
            const anchorGeo = turf.point([farthestPt.lng, farthestPt.lat]);
            
            // Считаем дистанции от "Якоря" до всех остальных в пуле
            const withDist = pool.map(p => ({
                p: p,
                d: turf.distance(anchorGeo, turf.point([p.lng, p.lat]))
            }));
            
            // Сортируем: сначала сама точка (дистанция 0), потом ближайшие
            withDist.sort((a, b) => a.d - b.d);

            // В. Берем первые MAX точек
            const chunk = withDist.slice(0, max).map(x => x.p);
            const chunkIds = new Set(chunk.map(x => x.id));

            // Г. Красим
            const col = getDistinctColor((hub.id.length + gCounter) * 7);
            chunk.forEach(p => {
                p.groupIndex = gCounter;
                p.color = col;
            });

            // Д. Удаляем их из пула и повышаем счетчик групп
            pool = pool.filter(p => !chunkIds.has(p.id));
            gCounter++;
        }
    }

    // --- ОТРИСОВКА ---
    function drawHubs() {
        layers.hubs.clearLayers();
        const icon = L.divIcon({
            className: '',
            html: "<div style='background:#0f172a; color:#fff; width:24px; height:24px; border-radius:50%; display:flex; align-items:center; justify-content:center; border:2px solid #fff; font-weight:bold;'>H</div>",
            iconSize: [28,28]
        });
        hubsData.forEach(h => L.marker([h.lat, h.lng], {icon}).addTo(layers.hubs));
    }

    function drawPoints() {
        layers.points.clearLayers();
        pointsData.forEach(p => {
            // Проверяем, выбрана ли точка сейчас (чтобы сохранить подсветку при перерисовке)
            const isSelected = selectedIds.has(p.id);
            const extraClass = isSelected ? 'selected-marker' : '';

            const icon = L.divIcon({
                className: '', // Важно оставить пустым, классы добавляем в html
                html: `<div class="pt-marker ${extraClass}" id="marker-${p.id}" style='background:${p.color}; width:10px; height:10px; border-radius:50%; border:1px solid #1e293b; transition:all 0.1s;'></div>`,
                iconSize: [12,12]
            });

            const m = L.marker([p.lat, p.lng], {icon});

            // ОБНОВЛЕННАЯ ЛОГИКА КЛИКА
            m.on('click', function(e) {
                if (selectionMode) {
                    // Если режим выбора - то выделяем/снимаем
                    togglePointSelection(p.id);
                } else {
                    // Если обычный режим - показываем попап вручную
                    const popupContent = `
                        <b>${p.id}</b><br>
                        СД: ${p.assignedHub}<br>
                        Група: <span style='font-size:1.2em; font-weight:bold'>${p.groupIndex}</span>
                        <hr style="border-color:#334155; margin:8px 0;">
                        <label style="margin-bottom:2px">Перемістити:</label>
                        <div class="popup-row">
                            <input type="number" id="m-${p.id}" value="${p.groupIndex}" style="width:60px">
                            <button class="small-btn" onclick="movePt('${p.id}')">OK</button>
                        </div>
                        <div class="popup-row" style="margin-top:8px">
                            <input type="number" id="mg-${p.id}" placeholder="№" style="width:60px">
                            <button class="small-btn" onclick="mergeGr('${p.id}')">Поєднати</button>
                        </div>
                    `;
                    L.popup()
                        .setLatLng(e.latlng)
                        .setContent(popupContent)
                        .openOn(map);
                }
            });

            m.addTo(layers.points);
        });
    }

    function drawBoundaries() {
        layers.polygons.clearLayers(); layers.labels.clearLayers();
        const gr = {};
        pointsData.forEach(p => {
            if(!p.assignedHub) return;
            const k = p.assignedHub + '_' + p.groupIndex;
            if(!gr[k]) gr[k] = {pts:[], c:p.color, i:p.groupIndex};
            gr[k].pts.push([p.lng, p.lat]);
        });
        
        Object.values(gr).forEach(g => {
            if(g.pts.length < 1) return;
            const tp = turf.points(g.pts);
            if(g.pts.length >= 3) {
                const hull = turf.convex(tp);
                if(hull) L.geoJSON(hull, {style: {color:g.c, weight:2, fillOpacity:0.3}}).addTo(layers.polygons);
            }
            let cent = (g.pts.length>=3) ? turf.centerOfMass(turf.convex(tp)) : turf.center(tp);
            const cc = cent.geometry.coordinates;
            const icon = L.divIcon({
                className: 'group-label', html: g.i, iconSize:[20,20], iconAnchor:[10,10]
            });
            L.marker([cc[1], cc[0]], {icon, interactive:false}).addTo(layers.labels);
        });
    }

    function redrawMap() { drawPoints(); drawBoundaries(); }

    // --- ПРАВКИ (FIXED VERSION) ---
    window.movePt = function(id) {
        const val = parseInt(document.getElementById('m-'+id).value);
        const p = pointsData.find(x => x.id === id);
        if(p && val) {
            p.groupIndex = val;
            p.color = getColor(p.assignedHub, val);
            map.closePopup(); redrawMap();
        }
    };
    
    window.mergeGr = function(id) {
        const pSrc = pointsData.find(x => x.id === id);
        const tIdx = parseInt(document.getElementById('mg-'+id).value);
        
        if(pSrc && tIdx && pSrc.groupIndex !== tIdx) {
            const tCol = getColor(pSrc.assignedHub, tIdx);
            // Фиксируем переменные до цикла
            const sHub = pSrc.assignedHub;
            const sGrp = pSrc.groupIndex;
            
            pointsData.forEach(p => {
                if(p.assignedHub === sHub && p.groupIndex === sGrp) {
                    p.groupIndex = tIdx; 
                    p.color = tCol;
                }
            });
            map.closePopup(); redrawMap();
        }
    };

    function getColor(hid, gidx) {
        const ex = pointsData.find(p => p.assignedHub === hid && p.groupIndex === gidx);
        return ex ? ex.color : getDistinctColor((hid.length+gidx)*13);
    }
    
    function getDistinctColor(i) {
        return `hsl(${(i * 137.5) % 360}, 75%, 55%)`;
    }

    function exportToExcel() {
        if(!pointsData.length) return;
        const ws = XLSX.utils.json_to_sheet(pointsData.map(p => ({
            "ID":p.id, "Lat":p.lat, "Lng":p.lng, "Hub":p.assignedHub, "Group":p.groupIndex
        })));
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "Export");
        XLSX.writeFile(wb, "Result.xlsx");
    }
    // --- ФУНКЦИИ МУЛЬТИВЫБОРА ---

    function toggleSelectionMode() {
        selectionMode = !selectionMode;
        const btn = document.getElementById('btnSelectMode');
        const panel = document.getElementById('bulkActions');
        
        if (selectionMode) {
            btn.style.background = '#facc15'; // Желтый фон
            btn.style.color = '#000';
            btn.innerText = 'Масове переміщення (Вимкнути)';
            panel.style.display = 'block';
        } else {
            btn.style.background = ''; 
            btn.style.color = '';
            btn.innerText = 'Масове переміщення';
            // Не скрываем панель сразу, если там есть выбранные, или можно скрыть:
            if(selectedIds.size === 0) panel.style.display = 'none';
        }
    }

    function togglePointSelection(id) {
        const el = document.getElementById('marker-' + id);
        if (selectedIds.has(id)) {
            selectedIds.delete(id);
            if(el) el.classList.remove('selected-marker');
        } else {
            selectedIds.add(id);
            if(el) el.classList.add('selected-marker');
        }
        document.getElementById('selCount').innerText = selectedIds.size;
    }

    function clearSelection() {
        selectedIds.clear();
        document.getElementById('selCount').innerText = 0;
        // Убираем классы визуально
        document.querySelectorAll('.selected-marker').forEach(el => el.classList.remove('selected-marker'));
        // Выключаем режим
        if(selectionMode) toggleSelectionMode();
        document.getElementById('bulkActions').style.display = 'none';
    }

    window.moveSelectedPoints = function() {
        // 1. Проверки
        const targetGroup = parseInt(document.getElementById('bulkGroupInput').value);
        if (!targetGroup && targetGroup !== 0) return alert("Вкажіть номер групи!");
        if (selectedIds.size === 0) return alert("Оберіть точки!");

        // 2. Кэш цветов, чтобы не вычислять одно и то же для каждой точки
        // Формат: { "НазваниеХаба_НомерГруппы": "Цвет" }
        const colorCache = {};

        pointsData.forEach(p => {
            // Нас интересуют только выбранные точки
            if (!selectedIds.has(p.id)) return;

            const hub = p.assignedHub;
            const key = hub + '_' + targetGroup;

            // Если мы еще не определили цвет для этой пары Хаб+Группа
            if (!colorCache[key]) {
                // Ищем "Старожила" — точку, которая УЖЕ в этой группе, 
                // но КОТОРАЯ НЕ находится в списке перемещаемых (selectedIds)
                const existingPoint = pointsData.find(ex => 
                    ex.assignedHub === hub && 
                    ex.groupIndex === targetGroup && 
                    !selectedIds.has(ex.id) // <--- ВОТ ГЛАВНОЕ ИСПРАВЛЕНИЕ
                );

                if (existingPoint) {
                    // Если нашли соседа, берем его цвет
                    colorCache[key] = existingPoint.color;
                } else {
                    // Если группа пустая или новая — генерируем новый уникальный цвет
                    // Используем ту же формулу, что и везде
                    colorCache[key] = getDistinctColor((hub.length + targetGroup) * 13);
                }
            }

            // 3. Применяем изменения
            p.groupIndex = targetGroup;
            p.color = colorCache[key];
        });

        // 4. Очистка и перерисовка
        selectedIds.clear();
        document.getElementById('selCount').innerText = 0;
        document.getElementById('bulkGroupInput').value = '';
        
        redrawMap();
    };


        const numberInputs = document.querySelectorAll('#maxCapacity, #bulkGroupInput');

            numberInputs.forEach(input => {
                input.addEventListener('wheel', function(e) {
                    e.preventDefault();
                    
                    // Если у поля есть атрибут step, берем его. Если нет — по умолчанию 1.
                    // (Для макс. вместимости у нас стоит step="5", а для номера группы будет 1)
                    const step = parseInt(this.getAttribute('step')) || 1;
                    
                    const direction = e.deltaY < 0 ? 1 : -1;
                    let currentVal = parseInt(this.value) || 0;
                    let newVal = currentVal + (step * direction);
                    
                    //if (newVal < 1) newVal = 1;
                    
                    this.value = newVal;
                }, { passive: false });
            });



</script>
</body>
</html>